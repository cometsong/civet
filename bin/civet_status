#!/usr/bin/env python

"""
   report on the status of a pipeline.  The pipeline is specified by providing
   the path to its log directory, which is unique for each pipeline
"""

import argparse
import sys
import os
import inspect

cmd_folder = os.path.realpath(os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0]))
lib_folder = os.path.join(cmd_folder, '../lib')
if lib_folder not in sys.path:
     sys.path.insert(0, lib_folder)

import job_runner.torque as batch_system
import job_runner.common
import version


def format_state(state):
    if state == 'R':
        return "Running"
    elif state == 'Q':
        return "Queued (eligible to run)"
    elif state == 'H':
        return "Queued (waiting on dependency)"
    elif state == 'W':
        return "Queued (with delayed start)"
    
    return state


def main():

    version.parse_options()
 

    parser = argparse.ArgumentParser(prog=os.path.basename(sys.argv[0]))
    parser.add_argument('-r', '--recursive', dest='recursive', action='store_true', help="Run in recursive mode")
    parser.add_argument('--verbose', dest='verbose', action='store_true', help="More verbose output")
    parser.add_argument('-q', '--quiet', dest='quiet', action='store_true', help="Only produce output for failed runs")
    parser.add_argument('dirs', help="Log directory", nargs=argparse.REMAINDER)
    parser.set_defaults(quiet=False)
    parser.set_defaults(verbose=False)
    parser.set_defaults(recursive=True)  # change default behavior to recursive, keep option to preserve backwards compatibility
    args = parser.parse_args()

    verbose = args.verbose
    quiet = args.quiet
    
    if verbose and quiet:
        sys.stderr.write("--quiet (-q) and --verbose options are mutually exclusive\n")
        return 1
    
    dir_list_arg = []
    
    if len(args.dirs) > 0:
        dir_list_arg = args.dirs
    else:
        dir_list_arg.append('.')

    if args.recursive:
        all_log_dirs = []
        for d in dir_list_arg:
            dirs = []
            for root, children, files in os.walk(d):
                if job_runner.common.BATCH_ID_LOG in files:
                    dirs.append(root)
            dirs.sort()
            all_log_dirs += dirs

        
        if len(all_log_dirs) == 0:
            sys.stderr.write("ERROR: no valid log directory found!\n")
            return 1
    else:
        all_log_dirs = dir_list_arg

    jm = batch_system.JobManager()

    for log_dir in all_log_dirs:
    
        log_dir = os.path.abspath(log_dir)
        run_canceled = False
    
        if verbose:
            print "\n\nGetting status for pipeline with log directory at:"
            print "\t{0}\n".format(log_dir)
    
        if not os.path.isdir(log_dir):
            sys.stderr.write("ERROR: {0} does not appear to be a valid pipeline log directory.\n".format(log_dir))
            continue
    
    
        # get listing of batch jobs from the pipeline's log directory
        # each line in batch_jobs is [batch_id, job_name, [dependencies]])
        try:
            batch_jobs = job_runner.common.jobs_from_logdir(log_dir)
        except IOError, e:
            sys.stderr.write("ERROR: '{0}' does not appear to be a valid pipeline log directory:\n".format(log_dir))
            sys.stderr.write("\t{0}\n".format(e))
            continue
    
        # check to see if the log directory was created with civet_run --no-submit
        if os.path.exists(os.path.join(log_dir, job_runner.common.NO_SUB_FLAG)):
            print log_dir + ":\n\tThis pipeline was run with --no-submit, so no status is applicable."
            continue
    
        # check for the abort.log -- this will indicate something went wrong with
        # the run
        run_aborted = False
        if verbose and os.path.exists(os.path.join(log_dir, "abort.log")):
            run_aborted = True
            print "WARNING: Pipeline aborted due to non-zero exit value of at least one job.  Details below.\n"
        
        if os.path.exists(os.path.join(log_dir, job_runner.common.CANCEL_LOG_FILENAME)):
            run_canceled = true
            if verbose:
                cancel_info = dict(line.strip().split('=') for line in open(os.path.join(log_dir, job_runner.common.CANCEL_LOG_FILENAME)))
                if 'DATESTAMP' in cancel_info:
                    print "PIPELINE WAS CANCELED by user at {1}\n".format(cancel_info['DATESTAMP'])
                else:
                    print "PIPELINE WAS CANCELED by user.\n"
    
        complete_jobs_success = 0
        complete_jobs_failure = 0
        canceled_jobs = 0
        running_jobs = 0
        held_jobs = 0
        delayed_jobs = 0
        queued_jobs = 0
        unknown_state = 0
        total_jobs = len(batch_jobs)
    
        for job in batch_jobs:
            if verbose:
                print "\n{0} ({1}):".format(job[1], job[0])
            
            
            if os.path.exists(os.path.join(log_dir, job[1] + job_runner.common.JOB_STATUS_SUFFIX)): 
                status = job_runner.common.get_status_from_file(log_dir, job[1])
                if 'canceled' in status or 'cancelled' in status:
                    if verbose:
                        print "\tJob canceled (state at cancel = {0})".format(format_state(status['state_at_cancel']))
                    canceled_jobs += 1
                
                if 'exit_status' in status:
                    if status['exit_status'] == '0':
                        complete_jobs_success += 1
                        if verbose:
                            print "\tFinished=Success"
                    else:
                        complete_jobs_failure += 1
                        if verbose:
                            print "\tFinished=Failure"
                    if verbose:
                        print "\tExit Status={0}".format(status['exit_status'])
                if verbose:
                    if 'walltime' in status:
                        print "\tWalltime={0}".format(status['walltime'])
                    if 'requested_walltime' in status:
                        print "\tWalltime(Requested)={0}".format(status['requested_walltime'])
            else:
                status = jm.query_job(job[0])
                if status:
                    if verbose:
                        print "\tState={0}".format(format_state(status.state))
                    if status.state == 'R' or status.state == 'C':
                        if status.state == 'R':
                            running_jobs += 1
                        else:
                            # if we got here the job is in state "C" but no 
                            # job_name-status.txt file was created.  Job must have 
                            # crashed or was canceled...
                            if status.exit_status == "0":
                                #This shouldn't happen... if there isn't
                                #a job_name-status.txt the exit status should be non-zero
                                #maybe we should print a warning here about the
                                #unexpected state
                                complete_jobs_success += 1
                                if verbose:
                                    print "\tFinished=Success"
                            else:
                                complete_jobs_failure += 1
                                if verbose:
                                    print "\tFinished=Failure"
                            if verbose:
                                print "\tExit Status={0}".format(status.exit_status)
                        if verbose:
                            print "\tWalltime={0}".format(status.walltime)
                            print "\tWalltime(Requested)={0}".format(status.requested_walltime)
                    elif status.state == 'H':
                        held_jobs += 1
                        if verbose:
                            print "\tWalltime(Requested)={0}".format(status.requested_walltime)
                            print "\tDepends on {0}".format(job[2])             
                    elif status.state == 'Q':
                        queued_jobs += 1
                        if verbose:
                            print "\tWalltime(Requested)={0}".format(status.requested_walltime)
                    elif status.state == 'W':
                        delayed_jobs += 1
                        if verbose:
                            print "\tWalltime(Requested)={0}".format(status.requested_walltime)

                        
                else:
                    if verbose:
                        if run_aborted:
                            print "\tpbs_server returned no information for job {0} (job aborted)".format(job[0])
                        elif run_canceled:
                            print "\tpbs_server returned no information for job {0} (pipeline canceled by user)".format(job[0])
                        else:
                            print "\tWARNING=pbs_server returned no information for job {0}.  Job may have been deleted or it may have crashed.".format(job[0])
                    unknown_state += 1
                

        if complete_jobs_failure:
            summary_status = "FAILED"
        elif run_canceled:
            summary_status = "CANCELED"
        elif complete_jobs_success == total_jobs:
            summary_status = "completed successfully"
        elif unknown_state:
            summary_status = "TERMINATED (reason unknown, possibly walltime limit exceeded)"
        else:
            summary_status = "running"
         
        if verbose:
            print "\nSummary:"
        elif not quiet or summary_status == "FAILED" or summary_status == "CANCELED":
            print "{0}: {1}".format(log_dir, summary_status)
            
        if verbose or (not quiet and complete_jobs_success != total_jobs):
            print("\tTotal Pipeline Jobs: {0}".format(total_jobs))
            print("\t\tCompleted Jobs (success): {0}".format(complete_jobs_success))
            print("\t\tCompleted Jobs (with error): {0}".format(complete_jobs_failure))
            print("\t\tRunning Jobs: {0}".format(running_jobs))
            print("\t\tPending Jobs (waiting for compute resources): {0}".format(queued_jobs))
            print("\t\tPending Jobs (waiting on dependency): {0}".format(held_jobs))
            if delayed_jobs:
                print("\t\tPending Jobs (delayed start): {0}".format(delayed_jobs))
            if canceled_jobs:
                print("\t\tCanceled Jobs: {0}".format(canceled_jobs))
            if unknown_state:
                print("\t\t{0} deleted or crashed jobs (status file not found and no record for job on pbs_server)".format(unknown_state))
        if verbose:
            print("\n\n")

if __name__ == '__main__':
    main()
